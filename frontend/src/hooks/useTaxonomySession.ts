/**
 * @fileoverview Hook for managing taxonomy classification sessions.
 * 
 * This module provides the main hook for managing the lifecycle of taxonomy sessions:
 * - File upload and classification processing via Azure Function
 * - Session persistence in IndexedDB
 * - Sector selection from taxonomy dictionary
 * - Session history management (create, delete, clear)
 * 
 * @module useTaxonomySession
 */

import { useState, useCallback, useEffect } from 'react'
import { apiClient } from '@/lib/api'
import * as XLSX from 'xlsx'
import { saveSession, getAllSessions, clearAllSessions, deleteSession } from '@/lib/database'

/**
 * Represents a taxonomy classification session.
 * Sessions are persisted in IndexedDB and contain all data needed
 * to display results and enable chat with the Copilot.
 */
export interface TaxonomySession {
    /** Unique identifier generated by the backend */
    sessionId: string
    /** Original filename of the uploaded file */
    filename: string
    /** Sector used for classification (e.g., 'Varejo', 'Educacional') */
    sector: string
    /** ISO timestamp of when the session was created */
    timestamp: string
    /** Summary statistics from classification (total, unique, ambiguous, none) */
    summary?: any
    /** Analytics data including Pareto, gaps, and ambiguity analysis */
    analytics?: any
    /** Array of classified items with N1-N4 categories */
    items?: any[]
    /** Runtime-only blob URL for downloading the Excel file */
    downloadUrl?: string
    /** Filename of the classified Excel file */
    downloadFilename?: string
    /** Base64-encoded file content for recreating downloads after page reload */
    fileContentBase64?: string
}

/**
 * Return type for the useTaxonomySession hook.
 * Contains all state and actions for managing taxonomy sessions.
 */
interface UseTaxonomySessionReturn {
    // State
    /** Array of all taxonomy sessions (persisted in IndexedDB) */
    sessions: TaxonomySession[]
    /** ID of the currently active session, or null */
    activeSessionId: string | null
    /** The currently active session object, or undefined */
    activeSession: TaxonomySession | undefined
    /** True when a file is being processed by the backend */
    isProcessing: boolean
    /** Currently selected sector for classification */
    sector: string
    /** Available sectors loaded from the taxonomy dictionary */
    sectors: string[]
    /** True while sectors are being loaded from the dictionary */
    isLoadingSectors: boolean
    /** Additional context about the client/project */
    clientContext: string
    /** Progress of the current operation */
    progress: { message: string, pct: number } | null

    // Actions
    /** Updates the selected sector */
    setSector: (sector: string) => void
    /** Updates the client context */
    setClientContext: (context: string) => void
    /** Sets the active session by ID (null to deselect) */
    setActiveSessionId: (id: string | null) => void
    /** Clears active session to show the upload form */
    handleNewUpload: () => void
    /** Processes an uploaded file and creates a new session */
    handleFileSelect: (file: File, fileContent: string, hierarchyContent?: string) => Promise<void>
    /** Clears all sessions from storage and state */
    handleClearHistory: () => void
    /** Deletes a specific session by ID */
    handleDeleteSession: (sessionId: string) => void
}

/**
 * Custom hook for managing taxonomy classification sessions.
 * 
 * Handles the complete lifecycle of classification sessions including:
 * file upload, processing, persistence, and deletion.
 * 
 * @returns Object containing session state and action methods
 * 
 * @example
 * ```tsx
 * const {
 *   sessions,
 *   activeSession,
 *   handleFileSelect,
 *   handleDeleteSession
 * } = useTaxonomySession()
 * ```
 */
export function useTaxonomySession(): UseTaxonomySessionReturn {
    const [sessions, setSessions] = useState<TaxonomySession[]>([])
    const [activeSessionId, setActiveSessionId] = useState<string | null>(null)
    const [isProcessing, setIsProcessing] = useState(false)
    const [sector, setSector] = useState('Varejo')
    const [sectors, setSectors] = useState<string[]>([])
    const [isLoadingSectors, setIsLoadingSectors] = useState(true)
    const [clientContext, setClientContext] = useState('')
    const [progress, setProgress] = useState<{ message: string, pct: number } | null>(null)

    const activeSession = sessions.find(s => s.sessionId === activeSessionId)

    // Load sessions from IndexedDB on mount
    useEffect(() => {
        const loadSessions = async () => {
            const storedSessions = await getAllSessions()
            if (storedSessions.length > 0) {
                setSessions(storedSessions)

                // Auto-select latest session if none is active
                if (storedSessions.length > 0 && !activeSessionId) {
                    console.log("[DEBUG] Auto-selecting latest session:", storedSessions[0].sessionId);
                    setActiveSessionId(storedSessions[0].sessionId)
                }
            }
        }
        loadSessions()
    }, [])

    // Load sectors from Spend_Taxonomy.xlsx
    useEffect(() => {
        const loadSectors = async () => {
            try {
                setIsLoadingSectors(true)
                const response = await fetch('/Spend_Taxonomy.xlsx')
                const arrayBuffer = await response.arrayBuffer()
                const workbook = XLSX.read(arrayBuffer, { type: 'array' })

                // Find CONFIG sheet
                const configSheetName = workbook.SheetNames.find(name => name.toUpperCase().includes('CONFIG')) || workbook.SheetNames[0]
                const worksheet = workbook.Sheets[configSheetName]

                const jsonData: any[] = XLSX.utils.sheet_to_json(worksheet)

                // Extract and filter sectors
                const loadedSectors = jsonData
                    .map((row: any) => row.Setor)
                    .filter((s: any) =>
                        s &&
                        typeof s === 'string' &&
                        s.trim().length > 0 &&
                        s.length < 30 &&
                        !s.toLowerCase().includes('essa aba diz')
                    )

                const uniqueSectors = Array.from(new Set(loadedSectors)) as string[]

                if (uniqueSectors.length > 0) {
                    // Add "Padrão (UNSPSC)" if not present
                    if (!uniqueSectors.includes('Padrão')) {
                        uniqueSectors.unshift('Padrão');
                    }

                    setSectors(uniqueSectors)
                    if (!uniqueSectors.includes(sector)) {
                        setSector(uniqueSectors[0])
                    }
                } else {
                    setSectors(['Padrão', 'Varejo', 'Educacional'])
                }

            } catch (error) {
                console.error("Error loading sectors:", error)
                setSectors(['Padrão', 'Varejo', 'Educacional'])
            } finally {
                setIsLoadingSectors(false)
            }
        }

        loadSectors()
    }, [])

    const handleNewUpload = useCallback(() => {
        setActiveSessionId(null)
    }, [])

    // Helper function to convert File to Base64 (Promise-based)
    const readFileAsBase64 = (file: File): Promise<string> => {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => {
                const base64String = (reader.result as string).split(',')[1];
                resolve(base64String);
            };
            reader.onerror = (error) => reject(error);
            reader.readAsDataURL(file);
        });
    };

    // Helper function to convert base64 to Blob (using atob + Uint8Array for max compatibility)
    const base64ToBlob = (base64: string, contentType: string): Blob => {
        if (!base64) return new Blob([], { type: contentType });
        const cleanBase64 = base64.replace(/\s/g, '').split(',').pop() || '';
        if (!cleanBase64) return new Blob([], { type: contentType });

        try {
            const byteCharacters = atob(cleanBase64);
            const byteArrays: Uint8Array[] = [];
            for (let offset = 0; offset < byteCharacters.length; offset += 512) {
                const slice = byteCharacters.slice(offset, offset + 512);
                const byteNumbers = new Uint8Array(slice.length);
                for (let i = 0; i < slice.length; i++) {
                    byteNumbers[i] = slice.charCodeAt(i);
                }
                byteArrays.push(byteNumbers);
            }
            return new Blob(byteArrays, { type: contentType });
        } catch (error) {
            console.error("Base64 to Blob failed:", error);
            return new Blob([], { type: contentType });
        }
    }

    const handleFileSelect = async (file: File, fileContent: string, hierarchyContent?: string) => {
        setIsProcessing(true)
        setProgress({ message: "Iniciando upload...", pct: 0 })

        try {
            let dictionaryBase64: string | undefined = undefined;

            // EXCLUSIVE MODE LOGIC:
            // If user provided a custom hierarchy, we SKIP fetching the default dictionary
            if (!hierarchyContent) {
                console.log("[DEBUG] No hierarchy provided, loading default dictionary...");
                const dictionaryResponse = await fetch('/Spend_Taxonomy.xlsx');
                if (!dictionaryResponse.ok) throw new Error("Falha ao carregar Spend_Taxonomy.xlsx");
                const dictionaryBlob = await dictionaryResponse.blob();
                dictionaryBase64 = await readFileAsBase64(dictionaryBlob as unknown as File);
            } else {
                console.log("[DEBUG] Custom Hierarchy provided. Activating Exclusive Mode.");
            }

            // Process file via Azure Function
            const result = await apiClient.processTaxonomy(
                fileContent,
                dictionaryBase64 || "",
                sector,
                file.name,
                hierarchyContent,
                clientContext,
                (msg, pct) => setProgress({ message: msg, pct }) // Progress Callback
            )

            if (!result || !result.sessionId) {
                throw new Error("Resposta da API inválida ou SessionId ausente.");
            }

            const newSession: TaxonomySession = {
                filename: file.name,
                sector: sector,
                sessionId: result.sessionId,
                summary: result.summary,
                analytics: result.analytics,
                items: result.items,
                downloadFilename: result.filenameDetail || result.filename || file.name,
                fileContentBase64: result.fileContent,
                timestamp: new Date().toISOString()
            }

            setSessions(prev => [newSession, ...prev])
            setActiveSessionId(result.sessionId)

            await saveSession(newSession)
        } catch (error: any) {
            console.error("Erro no processamento da taxonomia:", error);
            alert(`Erro ao processar arquivo: ${error.message || 'Erro desconhecido'}`);
        } finally {
            setIsProcessing(false)
        }
    }

    const handleClearHistory = useCallback(async () => {
        // Clear IndexedDB
        await clearAllSessions()

        // Clear localStorage chat entries
        const keysToRemove: string[] = []
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i)
            if (key?.startsWith('pg_spend_chat_')) {
                keysToRemove.push(key)
            }
        }
        keysToRemove.forEach(key => localStorage.removeItem(key))

        // Clear React state
        setSessions([])
        setActiveSessionId(null)
    }, [])

    const handleDeleteSession = useCallback(async (sessionId: string) => {
        // Delete from IndexedDB
        await deleteSession(sessionId)

        // Delete from localStorage
        localStorage.removeItem(`pg_spend_chat_${sessionId}`)

        // Update React state
        setSessions(prev => prev.filter(s => s.sessionId !== sessionId))

        // If deleting the active session, clear selection
        if (activeSessionId === sessionId) {
            setActiveSessionId(null)
        }
    }, [activeSessionId])

    return {
        sessions,
        activeSessionId,
        activeSession,
        isProcessing,
        sector,
        sectors,
        isLoadingSectors,
        clientContext,
        setSector,
        setClientContext,
        setActiveSessionId,
        handleNewUpload,
        handleFileSelect,
        handleClearHistory,
        handleDeleteSession,
        progress
    }
}

// Exported helper (synchronous, using atob for max compatibility)
export const base64ToBlobSync = (base64: string, contentType: string): Blob => {
    try {
        const cleanBase64 = base64.replace(/\s/g, '').split(',').pop() || '';
        if (!cleanBase64) return new Blob([], { type: contentType });
        const byteCharacters = atob(cleanBase64);
        const byteArrays: Uint8Array[] = [];
        for (let offset = 0; offset < byteCharacters.length; offset += 512) {
            const slice = byteCharacters.slice(offset, offset + 512);
            const byteNumbers = new Uint8Array(slice.length);
            for (let i = 0; i < slice.length; i++) {
                byteNumbers[i] = slice.charCodeAt(i);
            }
            byteArrays.push(byteNumbers);
        }
        return new Blob(byteArrays, { type: contentType });
    } catch (e) {
        console.error("Exported base64ToBlob failed:", e);
        return new Blob([], { type: contentType });
    }
}
